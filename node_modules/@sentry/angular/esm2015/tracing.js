import { Directive, Injectable, Input, NgModule } from '@angular/core';
import { NavigationEnd, NavigationStart, ResolveEnd } from '@angular/router';
import { getCurrentHub, WINDOW } from '@sentry/browser';
import { logger, stripUrlQueryAndFragment, timestampWithMs } from '@sentry/utils';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
let stashedStartTransaction;
let stashedStartTransactionOnLocationChange;
/**
 * Creates routing instrumentation for Angular Router.
 */
export function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
    instrumentationInitialized = true;
    stashedStartTransaction = customStartTransaction;
    stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {
        customStartTransaction({
            name: WINDOW.location.pathname,
            op: 'pageload',
            metadata: { source: 'url' },
        });
    }
}
export const instrumentAngularRouting = routingInstrumentation;
/**
 * Grabs active transaction off scope
 */
export function getActiveTransaction() {
    const currentHub = getCurrentHub();
    if (currentHub) {
        const scope = currentHub.getScope();
        if (scope) {
            return scope.getTransaction();
        }
    }
    return undefined;
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            let activeTransaction = getActiveTransaction();
            if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                activeTransaction = stashedStartTransaction({
                    name: strippedUrl,
                    op: 'navigation',
                    metadata: { source: 'url' },
                });
            }
            if (activeTransaction) {
                if (this._routingSpan) {
                    this._routingSpan.finish();
                }
                this._routingSpan = activeTransaction.startChild({
                    description: `${navigationEvent.url}`,
                    op: ANGULAR_ROUTING_OP,
                    tags: Object.assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                        navigationTrigger: navigationEvent.navigationTrigger,
                    })),
                });
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            const transaction = getActiveTransaction();
            // TODO (v8 / #5416): revisit the source condition. Do we want to make the parameterized route the default?
            if (transaction && transaction.metadata.source === 'url') {
                transaction.setName(route, 'route');
            }
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.finish();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
TraceService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TraceService_Factory() { return new TraceService(i0.ɵɵinject(i1.Router)); }, token: TraceService, providedIn: "root" });
TraceService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
TraceService.ctorParameters = () => [
    { type: Router }
];
const UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export class TraceDirective {
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        if (!this.componentName) {
            this.componentName = UNKNOWN_COMPONENT;
        }
        const activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            this._tracingSpan = activeTransaction.startChild({
                description: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
            });
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        if (this._tracingSpan) {
            this._tracingSpan.finish();
        }
    }
}
TraceDirective.decorators = [
    { type: Directive, args: [{ selector: '[trace]' },] }
];
TraceDirective.propDecorators = {
    componentName: [{ type: Input, args: ['trace',] }]
};
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TraceDirective],
                exports: [TraceDirective],
            },] }
];
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClassDecorator() {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function (...args) {
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                tracingSpan = activeTransaction.startChild({
                    description: `<${target.name}>`,
                    op: ANGULAR_INIT_OP,
                });
            }
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                tracingSpan.finish();
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethodDecorator() {
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function (...args) {
            const now = timestampWithMs();
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                activeTransaction.startChild({
                    description: `<${target.constructor.name}>`,
                    endTimestamp: now,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    startTimestamp: now,
                });
            }
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concantenated
 *
 * @returns the concatenated parameterzited route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const path = route && route.firstChild && route.firstChild.routeConfig && route.firstChild.routeConfig.path;
    if (!path) {
        return '/';
    }
    return `/${path}${getParameterizedRouteFromSnapshot(route && route.firstChild)}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9zZW50cnktamF2YXNjcmlwdC9zZW50cnktamF2YXNjcmlwdC9wYWNrYWdlcy9hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbInRyYWNpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2RSxPQUFPLEVBQUUsYUFBYSxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3RSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXhELE9BQU8sRUFBRSxNQUFNLEVBQUUsd0JBQXdCLEVBQUUsZUFBZSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWxGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3QyxPQUFPLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7O0FBRTNDLElBQUksMEJBQW1DLENBQUM7QUFDeEMsSUFBSSx1QkFBaUYsQ0FBQztBQUN0RixJQUFJLHVDQUFnRCxDQUFDO0FBRXJEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUNwQyxzQkFBZ0YsRUFDaEYsNkJBQXNDLElBQUksRUFDMUMsbUNBQTRDLElBQUk7SUFFaEQsMEJBQTBCLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLHVCQUF1QixHQUFHLHNCQUFzQixDQUFDO0lBQ2pELHVDQUF1QyxHQUFHLGdDQUFnQyxD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TUFBTSxpQkFBaUIsR0FBRyxvQkFBb0IsRUFBRSxDQUFDO1lBQ2pELElBQUksaUJBQWlCLEVBQUU7Z0JBQ3JCLGlCQUFpQixDQUFDLFVBQVUsQ0FBQztvQkFDM0IsV0FBVyxFQUFFLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUc7b0JBQzNDLFlBQVksRUFBRSxHQUFHO29CQUNqQixFQUFFLEVBQUUsR0FBRyxVQUFVLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFO29CQUMxQyxjQUFjLEVBQUUsR0FBRztpQkFDcEIsQ0FBQyxDQUFDO2FBQ0o7WUFDRCxJQUFJLGNBQWMsRUFBRTtnQkFDbEIsc0VBQXNFO2dCQUN0RSxPQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3pDO1FBQ0gsQ0FBQyxDQUFDO1FBQ0YsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxVQUFVLGlDQUFpQyxDQUFDLEtBQXFDO0lBQ3JGLE1BQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxLQUFLLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztJQUM1RyxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ1QsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUNELE9BQU8sSUFBSSxJQUFJLEdBQUcsaUNBQWlDLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDO0FBQ25GLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGluZXMgKi9cbmltcG9ydCB0eXBlIHsgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5qZWN0YWJsZSwgSW5wdXQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgdHlwZSB7IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIEV2ZW50LCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvblN0YXJ0LCBSZXNvbHZlRW5kIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGdldEN1cnJlbnRIdWIsIFdJTkRPVyB9IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG5pbXBvcnQgdHlwZSB7IFNwYW4sIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkNvbnRleHQgfSBmcm9tICdAc2VudHJ5L3R5cGVzJztcbmltcG9ydCB7IGxvZ2dlciwgc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50LCB0aW1lc3RhbXBXaXRoTXMgfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcbmltcG9ydCB0eXBlIHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQU5HVUxBUl9JTklUX09QLCBBTkdVTEFSX09QLCBBTkdVTEFSX1JPVVRJTkdfT1AgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBJU19ERUJVR19CVUlMRCB9IGZyb20gJy4vZmxhZ3MnO1xuaW1wb3J0IHsgcnVuT3V0c2lkZUFuZ3VsYXIgfSBmcm9tICcuL3pvbmUnO1xuXG5sZXQgaW5zdHJ1bWVudGF0aW9uSW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5sZXQgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb246IChjb250ZXh0OiBUcmFuc2FjdGlvbkNvbnRleHQpID0+IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkO1xubGV0IHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZTogYm9vbGVhbjtcblxuLyoqXG4gKiBDcmVhdGVzIHJvdXRpbmcgaW5zdHJ1bWVudGF0aW9uIGZvciBBbmd1bGFyIFJvdXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdXRpbmdJbnN0cnVtZW50YXRpb24oXG4gIGN1c3RvbVN0YXJ0VHJhbnNhY3Rpb246IChjb250ZXh0OiBUcmFuc2FjdGlvbkNvbnRleHQpID0+IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkLFxuICBzdGFydFRyYW5zYWN0aW9uT25QYWdlTG9hZDogYm9vbGVhbiA9IHRydWUsXG4gIHN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlOiBib29sZWFuID0gdHJ1ZSxcbik6IHZvaWQge1xuICBpbnN0cnVtZW50YXRpb25Jbml0aWFsaXplZCA9IHRydWU7XG4gIHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uID0gY3VzdG9tU3RhcnRUcmFuc2FjdGlvbjtcbiAgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlID0gc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2U7XG5cbiAgaWYgKHN0YXJ0VHJhbnNhY3Rpb25PblBhZ2VMb2FkICYmIFdJTkRPVyAmJiBXSU5ET1cubG9jYXRpb24pIHtcbiAgICBjdXN0b21TdGFydFRyYW5zYWN0aW9uKHtcbiAgICAgIG5hbWU6IFdJTkRPVy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIG9wOiAncGFnZWxvYWQnLFxuICAgICAgbWV0YWRhdGE6IHsgc291cmNlOiAndXJsJyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnN0cnVtZW50QW5ndWxhclJvdXRpbmcgPSByb3V0aW5nSW5zdHJ1bWVudGF0aW9uO1xuXG4vKipcbiAqIEdyYWJzIGFjdGl2ZSB0cmFuc2FjdGlvbiBvZmYgc2NvcGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk6IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgY3VycmVudEh1YiA9IGdldEN1cnJlbnRIdWIoKTtcblxuICBpZiAoY3VycmVudEh1Yikge1xuICAgIGNvbnN0IHNjb3BlID0gY3VycmVudEh1Yi5nZXRTY29wZSgpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgcmV0dXJuIHNjb3BlLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBbmd1bGFyJ3MgU2VydmljZSByZXNwb25zaWJsZSBmb3IgaG9va2luZyBpbnRvIEFuZ3VsYXIgUm91dGVyIGFuZCB0cmFja2luZyBjdXJyZW50IG5hdmlnYXRpb24gcHJvY2Vzcy5cbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24gZm9yIGV2ZXJ5IHJvdXRlIGNoYW5nZSBhbmQgbWVhc3VyZXMgYSBkdXJhdGlvbiBvZiByb3V0aW5nIHByb2Nlc3MuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHVibGljIG5hdlN0YXJ0JDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIE5hdmlnYXRpb25TdGFydCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCksXG4gICAgdGFwKG5hdmlnYXRpb25FdmVudCA9PiB7XG4gICAgICBpZiAoIWluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkKSB7XG4gICAgICAgIElTX0RFQlVHX0JVSUxEICYmXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdBbmd1bGFyIGludGVncmF0aW9uIGhhcyB0cmFjaW5nIGVuYWJsZWQsIGJ1dCBUcmFjaW5nIGludGVncmF0aW9uIGlzIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RyaXBwZWRVcmwgPSBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQobmF2aWdhdGlvbkV2ZW50LnVybCk7XG4gICAgICBsZXQgYWN0aXZlVHJhbnNhY3Rpb24gPSBnZXRBY3RpdmVUcmFuc2FjdGlvbigpO1xuXG4gICAgICBpZiAoIWFjdGl2ZVRyYW5zYWN0aW9uICYmIHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZSkge1xuICAgICAgICBhY3RpdmVUcmFuc2FjdGlvbiA9IHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICBuYW1lOiBzdHJpcHBlZFVybCxcbiAgICAgICAgICBvcDogJ25hdmlnYXRpb24nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7IHNvdXJjZTogJ3VybCcgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgICB0aGlzLl9yb3V0aW5nU3Bhbi5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3V0aW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtuYXZpZ2F0aW9uRXZlbnQudXJsfWAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfUk9VVElOR19PUCxcbiAgICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgICAncm91dGluZy5pbnN0cnVtZW50YXRpb24nOiAnQHNlbnRyeS9hbmd1bGFyJyxcbiAgICAgICAgICAgIHVybDogc3RyaXBwZWRVcmwsXG4gICAgICAgICAgICAuLi4obmF2aWdhdGlvbkV2ZW50Lm5hdmlnYXRpb25UcmlnZ2VyICYmIHtcbiAgICAgICAgICAgICAgbmF2aWdhdGlvblRyaWdnZXI6IG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlcixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIC8vIFRoZSBSZXNvbHZlRW5kIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIEFuZ3VsYXIgcm91dGVyIGhhcyByZXNvbHZlZCB0aGUgVVJMIGFuZFxuICAvLyB0aGUgcGFyYW1ldGVyPC0+dmFsdWUgbWFwcGluZy4gSXQgaG9sZHMgdGhlIG5ldyByZXNvbHZlZCByb3V0ZXIgc3RhdGUgd2l0aFxuICAvLyB0aGUgbWFwcGluZyBhbmQgdGhlIG5ldyBVUkwuXG4gIC8vIE9ubHkgQWZ0ZXIgdGhpcyBldmVudCwgdGhlIHJvdXRlIGlzIGFjdGl2YXRlZCwgbWVhbmluZyB0aGF0IHRoZSB0cmFuc2FjdGlvblxuICAvLyBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBwYXJhbWV0ZXJpemVkIHJvdXRlIG5hbWUgYmVmb3JlIGUuZy4gdGhlIHJvdXRlJ3Mgcm9vdFxuICAvLyBjb21wb25lbnQgaXMgaW5pdGlhbGl6ZWQuIFRoaXMgc2hvdWxkIGJlIGVhcmx5IGVub3VnaCBiZWZvcmUgb3V0Z29pbmcgcmVxdWVzdHNcbiAgLy8gYXJlIG1hZGUgZnJvbSB0aGUgbmV3IHJvdXRlLCB3aXRoIHRoZSBleGNlcHRpb25zIG9mIHJlcXVlc3RzIGJlaW5nIG1hZGUgZHVyaW5nXG4gIC8vIGEgbmF2aWdhdGlvbi5cbiAgcHVibGljIHJlc0VuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcigoZXZlbnQpOiBldmVudCBpcyBSZXNvbHZlRW5kID0+IGV2ZW50IGluc3RhbmNlb2YgUmVzb2x2ZUVuZCksXG4gICAgdGFwKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHJvdXRlID0gZ2V0UGFyYW1ldGVyaXplZFJvdXRlRnJvbVNuYXBzaG90KGV2ZW50LnN0YXRlLnJvb3QpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICAvLyBUT0RPICh2OCAvICM1NDE2KTogcmV2aXNpdCB0aGUgc291cmNlIGNvbmRpdGlvbi4gRG8gd2Ugd2FudCB0byBtYWtlIHRoZSBwYXJhbWV0ZXJpemVkIHJvdXRlIHRoZSBkZWZhdWx0P1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLm1ldGFkYXRhLnNvdXJjZSA9PT0gJ3VybCcpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2V0TmFtZShyb3V0ZSwgJ3JvdXRlJyk7XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgcHVibGljIG5hdkVuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpLFxuICAgIHRhcCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4hLmZpbmlzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPSBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIHByaXZhdGUgX3JvdXRpbmdTcGFuOiBTcGFuIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3JvdXRlcjogUm91dGVyKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLm5hdlN0YXJ0JC5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLnJlc0VuZCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZFbmQkLnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgd2hlbiB0aGUgcm9vdCB2aWV3IGlzIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBtdWx0aXBsZSB0aW1lcyxcbiAgICogc2luY2UgYHN1YnNjcmliZWAgY2FsbGJhY2tzIGNhcHR1cmUgYHRoaXNgIGFuZCBwcmV2ZW50IG1hbnkgcmVzb3VyY2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICovXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuXG5jb25zdCBVTktOT1dOX0NPTVBPTkVOVCA9ICd1bmtub3duJztcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t0cmFjZV0nIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3RyYWNlJykgcHVibGljIGNvbXBvbmVudE5hbWU/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfdHJhY2luZ1NwYW4/OiBTcGFuO1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBPbkluaXQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBVTktOT1dOX0NPTVBPTkVOVDtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICBkZXNjcmlwdGlvbjogYDwke3RoaXMuY29tcG9uZW50TmFtZX0+YCxcbiAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBBZnRlclZpZXdJbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3RyYWNpbmdTcGFuKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3Bhbi5maW5pc2goKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1vZHVsZSBzZXJ2ZXMgYXMgYSBzaW5nbGUgY29tcGlsYXRpb24gdW5pdCBmb3IgdGhlIGBUcmFjZURpcmVjdGl2ZWAgYW5kIGNhbiBiZSByZS11c2VkIGJ5IGFueSBvdGhlciBtb2R1bGUuXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1RyYWNlRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1RyYWNlRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhY2VNb2R1bGUge31cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGluaXRpYWxpemF0aW9uIGxpZmVjeWNsZSBvZiB0aGUgd2hvbGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gVHJhY2VDbGFzc0RlY29yYXRvcigpOiBDbGFzc0RlY29yYXRvciB7XG4gIGxldCB0cmFjaW5nU3BhbjogU3BhbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuICByZXR1cm4gdGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE9uSW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0YXJnZXQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxPbkluaXQ+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zYWN0aW9uID0gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKTtcbiAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICB0cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgPCR7dGFyZ2V0Lm5hbWV9PmAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxPbkluaXQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Jbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbEFmdGVyVmlld0luaXQgPSB0YXJnZXQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxBZnRlclZpZXdJbml0PiB7XG4gICAgICBpZiAodHJhY2luZ1NwYW4pIHtcbiAgICAgICAgdHJhY2luZ1NwYW4uZmluaXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxBZnRlclZpZXdJbml0KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEFmdGVyVmlld0luaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGEgc2luZ2xlIGxpZmVjeWNsZSBtZXRob2RzIG9mIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZU1ldGhvZERlY29yYXRvcigpOiBNZXRob2REZWNvcmF0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlLCBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIHJldHVybiAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbE1ldGhvZD4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZXN0YW1wV2l0aE1zKCk7XG4gICAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGA8JHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0+YCxcbiAgICAgICAgICBlbmRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICBvcDogYCR7QU5HVUxBUl9PUH0uJHtTdHJpbmcocHJvcGVydHlLZXkpfWAsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSBmcm9tIGEgZ2l2ZW4gQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSBzbmFwc2hvdCdzXG4gKiBjaGlsZCByb3V0ZSB3aXRoIGl0cyBwYXJlbnQgdG8gcHJvZHVjZSB0aGUgY29tcGxldGUgcGFyYW1ldGVyaXplZCBVUkwgb2YgdGhlIGFjdGl2YXRlZCByb3V0ZS5cbiAqIFRoaXMgaGFwcGVucyByZWN1cnNpdmVseSB1bnRpbCB0aGUgbGFzdCBjaGlsZCAoaS5lLiB0aGUgZW5kIG9mIHRoZSBVUkwpIGlzIHJlYWNoZWQuXG4gKlxuICogQHBhcmFtIHJvdXRlIHRoZSBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IG9mIHdoaWNoIGl0cyBwYXRoIGFuZCBpdHMgY2hpbGQncyBwYXRoIGlzIGNvbmNhbnRlbmF0ZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUgY29uY2F0ZW5hdGVkIHBhcmFtZXRlcnppdGVkIHJvdXRlIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyaXplZFJvdXRlRnJvbVNuYXBzaG90KHJvdXRlPzogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB8IG51bGwpOiBzdHJpbmcge1xuICBjb25zdCBwYXRoID0gcm91dGUgJiYgcm91dGUuZmlyc3RDaGlsZCAmJiByb3V0ZS5maXJzdENoaWxkLnJvdXRlQ29uZmlnICYmIHJvdXRlLmZpcnN0Q2hpbGQucm91dGVDb25maWcucGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gYC8ke3BhdGh9JHtnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3Qocm91dGUgJiYgcm91dGUuZmlyc3RDaGlsZCl9YDtcbn1cbiJdfQ==