import type { AfterViewInit, OnDestroy, OnInit } from '@angular/core';
import type { ActivatedRouteSnapshot, Event, Router } from '@angular/router';
import type { Transaction, TransactionContext } from '@sentry/types';
import type { Observable } from 'rxjs';
/**
 * Creates routing instrumentation for Angular Router.
 */
import * as ɵngcc0 from '@angular/core';
export declare function routingInstrumentation(customStartTransaction: (context: TransactionContext) => Transaction | undefined, startTransactionOnPageLoad?: boolean, startTransactionOnLocationChange?: boolean): void;
export declare const instrumentAngularRouting: typeof routingInstrumentation;
/**
 * Grabs active transaction off scope
 */
export declare function getActiveTransaction(): Transaction | undefined;
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export declare class TraceService implements OnDestroy {
    private readonly _router;
    navStart$: Observable<Event>;
    resEnd$: Observable<Event>;
    navEnd$: Observable<Event>;
    private _routingSpan;
    private _subscription;
    constructor(_router: Router);
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<TraceService, never>;
}
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export declare class TraceDirective implements OnInit, AfterViewInit {
    componentName?: string;
    private _tracingSpan?;
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit(): void;
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<TraceDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDeclaration<TraceDirective, "[trace]", never, { "componentName": "trace"; }, {}, never, never, false, never>;
}
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export declare class TraceModule {
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<TraceModule, never>;
    static ɵmod: ɵngcc0.ɵɵNgModuleDeclaration<TraceModule, [typeof TraceDirective], never, [typeof TraceDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDeclaration<TraceModule>;
}
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export declare function TraceClassDecorator(): ClassDecorator;
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export declare function TraceMethodDecorator(): MethodDecorator;
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concantenated
 *
 * @returns the concatenated parameterzited route string
 */
export declare function getParameterizedRouteFromSnapshot(route?: ActivatedRouteSnapshot | null): string;

//# sourceMappingURL=tracing.d.ts.map