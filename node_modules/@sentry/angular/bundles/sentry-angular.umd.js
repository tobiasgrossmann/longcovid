(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@sentry/browser'), require('@angular/core'), require('@sentry/utils'), require('@angular/common/http'), require('@angular/router'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@sentry/angular', ['exports', '@sentry/browser', '@angular/core', '@sentry/utils', '@angular/common/http', '@angular/router', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.sentry = global.sentry || {}, global.sentry.angular = {}), global.Sentry, global.ng.core, global.Sentry.util, global.ng.common.http, global.ng.router, global.rxjs, global.rxjs.operators));
})(this, (function (exports, Sentry, i0, utils, http, i1, rxjs, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var Sentry__namespace = /*#__PURE__*/_interopNamespace(Sentry);
    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    var ANGULAR_ROUTING_OP = 'ui.angular.routing';
    var ANGULAR_INIT_OP = 'ui.angular.init';
    var ANGULAR_OP = 'ui.angular';
    /**
     * Minimum Angular version this SDK supports
     */
    var ANGULAR_MINIMUM_VERSION = 10;

    /*
     * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
     * for users.
     *
     * We define "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during our, or the user's
     * build process. Take care when introducing new flags - they must not throw if they are not replaced. See the Debug
     * Build Flags section in CONTRIBUTING.md.
     */
    /** Flag that is true for debug builds, false otherwise. */
    var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

    /**
     * Inits the Angular SDK
     */
    function init(options) {
        options._metadata = options._metadata || {};
        options._metadata.sdk = {
            name: 'sentry.javascript.angular',
            packages: [
                {
                    name: 'npm:@sentry/angular',
                    version: Sentry.SDK_VERSION,
                },
            ],
            version: Sentry.SDK_VERSION,
        };
        checkAndSetAngularVersion();
        Sentry.init(options);
    }
    function checkAndSetAngularVersion() {
        var angularVersion = i0.VERSION && i0.VERSION.major ? parseInt(i0.VERSION.major, 10) : undefined;
        if (angularVersion) {
            if (angularVersion < ANGULAR_MINIMUM_VERSION) {
                IS_DEBUG_BUILD &&
                    utils.logger.warn("The Sentry SDK does not officially support Angular " + angularVersion + ".", "This version of the Sentry SDK supports Angular " + ANGULAR_MINIMUM_VERSION + " and above.", 'Please consider upgrading your Angular version or downgrading the Sentry SDK.');
            }
            Sentry.setContext('angular', { version: angularVersion });
        }
    }

    // There're 2 types of Angular applications:
    // 1) zone-full (by default)
    // 2) zone-less
    // The developer can avoid importing the `zone.js` package and tells Angular that
    // he is responsible for running the change detection by himself. This is done by
    // "nooping" the zone through `CompilerOptions` when bootstrapping the root module.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    var isNgZoneEnabled = typeof Zone !== 'undefined' && !!Zone.current;
    /**
     * The function that does the same job as `NgZone.runOutsideAngular`.
     */
    function runOutsideAngular(callback) {
        // The `Zone.root.run` basically will run the `callback` in the most parent zone.
        // Any asynchronous API used inside the `callback` won't catch Angular's zone
        // since `Zone.current` will reference `Zone.root`.
        // The Angular's zone is forked from the `Zone.root`. In this case, `zone.js` won't
        // trigger change detection, and `ApplicationRef.tick()` will not be run.
        // Caretaker note: we're using `Zone.root` except `NgZone.runOutsideAngular` since this
        // will require injecting the `NgZone` facade. That will create a breaking change for
        // projects already using the `@sentry/angular`.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return isNgZoneEnabled ? Zone.root.run(callback) : callback();
    }

    // https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts
    function tryToUnwrapZonejsError(error) {
        // TODO: once Angular14 is the minimum requirement ERROR_ORIGINAL_ERROR and
        //  getOriginalError from error.ts can be used directly.
        return error && error.ngOriginalError
            ? error.ngOriginalError
            : error;
    }
    function extractHttpModuleError(error) {
        // The `error` property of http exception can be either an `Error` object, which we can use directly...
        if (isErrorOrErrorLikeObject(error.error)) {
            return error.error;
        }
        // ... or an`ErrorEvent`, which can provide us with the message but no stack...
        if (error.error instanceof ErrorEvent && error.error.message) {
            return error.error.message;
        }
        // ...or the request body itself, which we can use as a message instead.
        if (typeof error.error === 'string') {
            return "Server returned code " + error.status + " with body \"" + error.error + "\"";
        }
        // If we don't have any detailed information, fallback to the request message itself.
        return error.message;
    }
    function isErrorOrErrorLikeObject(value) {
        if (value instanceof Error) {
            return true;
        }
        if (value === null || typeof value !== 'object') {
            return false;
        }
        var candidate = value;
        return (utils.isString(candidate.name) &&
            utils.isString(candidate.name) &&
            utils.isString(candidate.message) &&
            (undefined === candidate.stack || utils.isString(candidate.stack)));
    }
    /**
     * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.
     */
    var SentryErrorHandler = /** @class */ (function () {
        function SentryErrorHandler(options) {
            this._options = Object.assign({ logErrors: true }, options);
        }
        /**
         * Method called for every value captured through the ErrorHandler
         */
        SentryErrorHandler.prototype.handleError = function (error) {
            var extractedError = this._extractError(error) || 'Handled unknown error';
            // Capture handled exception and send it to Sentry.
            var eventId = runOutsideAngular(function () { return Sentry.captureException(extractedError, function (scope) {
                scope.addEventProcessor(function (event) {
                    utils.addExceptionMechanism(event, {
                        type: 'angular',
                        handled: false,
                    });
                    return event;
                });
                return scope;
            }); });
            // When in development mode, log the error to console for immediate feedback.
            if (this._options.logErrors) {
                // eslint-disable-next-line no-console
                console.error(extractedError);
            }
            // Optionally show user dialog to provide details on what happened.
            if (this._options.showDialog) {
                Sentry__namespace.showReportDialog(Object.assign(Object.assign({}, this._options.dialogOptions), { eventId: eventId }));
            }
        };
        /**
         * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.
         */
        SentryErrorHandler.prototype._extractError = function (error) {
            // Allow custom overrides of extracting function
            if (this._options.extractor) {
                var defaultExtractor = this._defaultExtractor.bind(this);
                return this._options.extractor(error, defaultExtractor);
            }
            return this._defaultExtractor(error);
        };
        /**
         * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.
         */
        SentryErrorHandler.prototype._defaultExtractor = function (errorCandidate) {
            var error = tryToUnwrapZonejsError(errorCandidate);
            // If it's http module error, extract as much information from it as we can.
            if (error instanceof http.HttpErrorResponse) {
                return extractHttpModuleError(error);
            }
            // We can handle messages and Error objects directly.
            if (typeof error === 'string' || isErrorOrErrorLikeObject(error)) {
                return error;
            }
            // Nothing was extracted, fallback to default error message.
            return null;
        };
        return SentryErrorHandler;
    }());
    SentryErrorHandler.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function SentryErrorHandler_Factory() { return new SentryErrorHandler(i0__namespace.ɵɵinject("errorHandlerOptions")); }, token: SentryErrorHandler, providedIn: "root" });
    SentryErrorHandler.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    SentryErrorHandler.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: ['errorHandlerOptions',] }] }
    ]; };
    /**
     * Factory function that creates an instance of a preconfigured ErrorHandler provider.
     */
    function createErrorHandler(config) {
        return new SentryErrorHandler(config);
    }

    var instrumentationInitialized;
    var stashedStartTransaction;
    var stashedStartTransactionOnLocationChange;
    /**
     * Creates routing instrumentation for Angular Router.
     */
    function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
        if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
        if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
        instrumentationInitialized = true;
        stashedStartTransaction = customStartTransaction;
        stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
        if (startTransactionOnPageLoad && Sentry.WINDOW && Sentry.WINDOW.location) {
            customStartTransaction({
                name: Sentry.WINDOW.location.pathname,
                op: 'pageload',
                metadata: { source: 'url' },
            });
        }
    }
    var instrumentAngularRouting = routingInstrumentation;
    /**
     * Grabs active transaction off scope
     */
    function getActiveTransaction() {
        var currentHub = Sentry.getCurrentHub();
        if (currentHub) {
            var scope = currentHub.getScope();
            if (scope) {
                return scope.getTransaction();
            }
        }
        return undefined;
    }
    /**
     * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
     * Creates a new transaction for every route change and measures a duration of routing process.
     */
    var TraceService = /** @class */ (function () {
        function TraceService(_router) {
            var _this = this;
            this._router = _router;
            this.navStart$ = this._router.events.pipe(operators.filter(function (event) { return event instanceof i1.NavigationStart; }), operators.tap(function (navigationEvent) {
                if (!instrumentationInitialized) {
                    IS_DEBUG_BUILD &&
                        utils.logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                    return;
                }
                var strippedUrl = utils.stripUrlQueryAndFragment(navigationEvent.url);
                var activeTransaction = getActiveTransaction();
                if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                    activeTransaction = stashedStartTransaction({
                        name: strippedUrl,
                        op: 'navigation',
                        metadata: { source: 'url' },
                    });
                }
                if (activeTransaction) {
                    if (_this._routingSpan) {
                        _this._routingSpan.finish();
                    }
                    _this._routingSpan = activeTransaction.startChild({
                        description: "" + navigationEvent.url,
                        op: ANGULAR_ROUTING_OP,
                        tags: Object.assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                            navigationTrigger: navigationEvent.navigationTrigger,
                        })),
                    });
                }
            }));
            // The ResolveEnd event is fired when the Angular router has resolved the URL and
            // the parameter<->value mapping. It holds the new resolved router state with
            // the mapping and the new URL.
            // Only After this event, the route is activated, meaning that the transaction
            // can be updated with the parameterized route name before e.g. the route's root
            // component is initialized. This should be early enough before outgoing requests
            // are made from the new route, with the exceptions of requests being made during
            // a navigation.
            this.resEnd$ = this._router.events.pipe(operators.filter(function (event) { return event instanceof i1.ResolveEnd; }), operators.tap(function (event) {
                var route = getParameterizedRouteFromSnapshot(event.state.root);
                var transaction = getActiveTransaction();
                // TODO (v8 / #5416): revisit the source condition. Do we want to make the parameterized route the default?
                if (transaction && transaction.metadata.source === 'url') {
                    transaction.setName(route, 'route');
                }
            }));
            this.navEnd$ = this._router.events.pipe(operators.filter(function (event) { return event instanceof i1.NavigationEnd; }), operators.tap(function () {
                if (_this._routingSpan) {
                    runOutsideAngular(function () {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        _this._routingSpan.finish();
                    });
                    _this._routingSpan = null;
                }
            }));
            this._routingSpan = null;
            this._subscription = new rxjs.Subscription();
            this._subscription.add(this.navStart$.subscribe());
            this._subscription.add(this.resEnd$.subscribe());
            this._subscription.add(this.navEnd$.subscribe());
        }
        /**
         * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
         * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
         */
        TraceService.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        return TraceService;
    }());
    TraceService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function TraceService_Factory() { return new TraceService(i0__namespace.ɵɵinject(i1__namespace.Router)); }, token: TraceService, providedIn: "root" });
    TraceService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    TraceService.ctorParameters = function () { return [
        { type: Router }
    ]; };
    var UNKNOWN_COMPONENT = 'unknown';
    /**
     * A directive that can be used to capture initialization lifecycle of the whole component.
     */
    var TraceDirective = /** @class */ (function () {
        function TraceDirective() {
        }
        /**
         * Implementation of OnInit lifecycle method
         * @inheritdoc
         */
        TraceDirective.prototype.ngOnInit = function () {
            if (!this.componentName) {
                this.componentName = UNKNOWN_COMPONENT;
            }
            var activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                this._tracingSpan = activeTransaction.startChild({
                    description: "<" + this.componentName + ">",
                    op: ANGULAR_INIT_OP,
                });
            }
        };
        /**
         * Implementation of AfterViewInit lifecycle method
         * @inheritdoc
         */
        TraceDirective.prototype.ngAfterViewInit = function () {
            if (this._tracingSpan) {
                this._tracingSpan.finish();
            }
        };
        return TraceDirective;
    }());
    TraceDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[trace]' },] }
    ];
    TraceDirective.propDecorators = {
        componentName: [{ type: i0.Input, args: ['trace',] }]
    };
    /**
     * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
     */
    var TraceModule = /** @class */ (function () {
        function TraceModule() {
        }
        return TraceModule;
    }());
    TraceModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [TraceDirective],
                    exports: [TraceDirective],
                },] }
    ];
    /**
     * Decorator function that can be used to capture initialization lifecycle of the whole component.
     */
    function TraceClassDecorator() {
        var tracingSpan;
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
        return function (target) {
            var originalOnInit = target.prototype.ngOnInit;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            target.prototype.ngOnInit = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var activeTransaction = getActiveTransaction();
                if (activeTransaction) {
                    tracingSpan = activeTransaction.startChild({
                        description: "<" + target.name + ">",
                        op: ANGULAR_INIT_OP,
                    });
                }
                if (originalOnInit) {
                    return originalOnInit.apply(this, args);
                }
            };
            var originalAfterViewInit = target.prototype.ngAfterViewInit;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            target.prototype.ngAfterViewInit = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (tracingSpan) {
                    tracingSpan.finish();
                }
                if (originalAfterViewInit) {
                    return originalAfterViewInit.apply(this, args);
                }
            };
        };
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    }
    /**
     * Decorator function that can be used to capture a single lifecycle methods of the component.
     */
    function TraceMethodDecorator() {
        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
        return function (target, propertyKey, descriptor) {
            var originalMethod = descriptor.value;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var now = utils.timestampWithMs();
                var activeTransaction = getActiveTransaction();
                if (activeTransaction) {
                    activeTransaction.startChild({
                        description: "<" + target.constructor.name + ">",
                        endTimestamp: now,
                        op: ANGULAR_OP + "." + String(propertyKey),
                        startTimestamp: now,
                    });
                }
                if (originalMethod) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    return originalMethod.apply(this, args);
                }
            };
            return descriptor;
        };
    }
    /**
     * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
     * child route with its parent to produce the complete parameterized URL of the activated route.
     * This happens recursively until the last child (i.e. the end of the URL) is reached.
     *
     * @param route the ActivatedRouteSnapshot of which its path and its child's path is concantenated
     *
     * @returns the concatenated parameterzited route string
     */
    function getParameterizedRouteFromSnapshot(route) {
        var path = route && route.firstChild && route.firstChild.routeConfig && route.firstChild.routeConfig.path;
        if (!path) {
            return '/';
        }
        return "/" + path + getParameterizedRouteFromSnapshot(route && route.firstChild);
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.SentryErrorHandler = SentryErrorHandler;
    exports.TraceClassDecorator = TraceClassDecorator;
    exports.TraceDirective = TraceDirective;
    exports.TraceMethodDecorator = TraceMethodDecorator;
    exports.TraceModule = TraceModule;
    exports.TraceService = TraceService;
    exports.createErrorHandler = createErrorHandler;
    exports.getActiveTransaction = getActiveTransaction;
    exports.init = init;
    exports.instrumentAngularRouting = instrumentAngularRouting;
    exports.routingInstrumentation = routingInstrumentation;
    Object.keys(Sentry).forEach(function (k) {
        if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
            enumerable: true,
            get: function () { return Sentry[k]; }
        });
    });

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=sentry-angular.umd.js.map
